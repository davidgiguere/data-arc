{"ast":null,"code":"import _toConsumableArray from \"/Users/erikwoodworth/Coding/ARC/data-arc/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nvar _jsxFileName = \"/Users/erikwoodworth/Coding/ARC/data-arc/src/components/MapLayers/GeoJSONLayer/index.js\";\nimport React from \"react\";\nimport L from 'leaflet';\nimport { GeoJSON } from 'react-leaflet';\nimport colormap from 'colormap';\n\nvar GeoJSONLayer = function GeoJSONLayer(props) {\n  // console.log(props.data)\n  // const pointData = props.data.geojson.map(feature => feature.geometry.type === 'Point' ? L. : null);\n  // console.log(props.data ? props.data : 'no data to geojson layer yet');\n  var numberOfBins = props.layout.numberOfBins;\n  var colorMap = props.layout.colorMap;\n  var reverse = props.layout.colorMapReverse; //  props.data.geojson ? props.data.geojson.forEach(feature => feature.geometry.type === 'Point' ? L.pointToLayer(feature.geometry.type) : console.log('Is not point')) : null;\n\n  var colors = reverse ? colormap({\n    colormap: colorMap,\n    nshades: numberOfBins,\n    format: 'hex',\n    alpha: 1\n  }).reverse() : colormap({\n    colormap: colorMap,\n    nshades: numberOfBins,\n    format: 'hex',\n    alpha: 1\n  });\n  var valueArray = props.data ? props.data.features.filter(function (feature) {\n    return feature.properties[props.selectedVariable];\n  }).map(function (feature) {\n    var variable = feature.properties[props.selectedVariable]; //   const normalizer=props.normalizedBy ? feature.properties[props.normalizedBy] : 1\n    // console.log(variable ? variable : null);\n\n    return variable;\n  }) : null;\n  var maxValue = valueArray !== null ? Math.max.apply(Math, _toConsumableArray(valueArray)) : 'Value array not load yet';\n  var minValue = valueArray !== null ? Math.min.apply(Math, _toConsumableArray(valueArray)) : 'Value array not load yet'; // console.log(valueArray ? valueArray : 'no value array');\n  // console.log(props.data)\n  // console.log(maxValue);\n  // console.log(minValue);\n\n  var geojsonData = props.data ? props.data : null; // console.log(geojsonData);\n  //   props.geographyFilter ? \n  //   //If there's a filter type\n  //   props.data.filter(feature => \n  //     feature.properties[props.selectedVariable] > 0 && feature.properties[props.geographyFilter] === props.geographyFilterValue )\n  //   //If there isn't a filter type\n  //     : props.data;\n  // const pointData = dataArray.map(feature => feature.geometry.type === 'Point' ? console.log(feature.geometry.type) : null);\n  // var geojsonMarkerOptions = {\n  //   radius: 20,\n  //   fillColor: \"#ff7800\",\n  //   color: \"#000\",\n  //   weight: 1,\n  //   opacity: 1,\n  //   fillOpacity: 0.8\n  // };\n  // const pointData = dataArray && props.data.point ? dataArray.map(feature => L.circleMarker(feature.geometry.coordinates, geojsonMarkerOptions)) : null;\n  //   // L.geoJSON(dataArray, {\n  //   // pointToLayer: (feature, latlng) => {\n  //   //   console.log(\"This is a point\")\n  //   //   return L.circleMarker(latlng, geojsonMarkerOptions )\n  //   // }\n  //   // }) \n\n  return React.createElement(GeoJSON, {\n    key: 'geojson-layer',\n    data: geojsonData //   pointToLayer={props.data.point ? (feature, latlng) => {\n    //     const variable=feature.properties[props.data.selectedVariable];\n    //     const normalizer=props.data.normalizedBy ? feature.properties[props.data.normalizedBy] : 1\n    //     // console.log(props.data.selectedVariable);\n    //     const value = variable/normalizer;\n    //     const distFromMin = value - minValue;\n    //     const range = maxValue - minValue;\n    //     const binningRatio = distFromMin/range;\n    //     const indexRange = numberOfBins - 1;\n    //     // const opacity = value;\n    //     const color = colors[Math.floor(binningRatio * indexRange)];\n    //     // const featureID = feature.properties[props.data.hoverField];\n    //     var geojsonMarkerOptions = {\n    //       // radius: 10,\n    //       fillColor: color,\n    //       color: \"#000\",\n    //       weight: 1,\n    //     };  \n    //     // console.log(\"This is a point\")\n    //       return L.circleMarker(latlng, geojsonMarkerOptions )\n    //               .setRadius(5)\n    //     } : null \n    //   }\n    ,\n    style: function style(feature) {\n      var variable = feature.properties ? feature.properties[props.selectedVariable] : null;\n      var normalizer = props.normalizedBy ? feature.properties[props.normalizedBy] : 1; // console.log(props.data.selectedVariable);\n\n      var value = variable / normalizer;\n      var distFromMin = value - minValue;\n      var range = maxValue - minValue;\n      var binningRatio = distFromMin / range;\n      var indexRange = numberOfBins - 1; // const opacity = value;\n\n      var color = value ? colors[Math.floor(value === 0 ? 0 : binningRatio * indexRange)] : null;\n      var featureID = feature.properties[props.hoverField]; // console.log(featureID);\n\n      return {\n        color: props.hoverID === featureID ? 'black' : '#1a1d62',\n        weight: props.hoverID === featureID ? 3 : 0.4,\n        fillColor: color,\n        fillOpacity: !value ? 0 : props.hoverID === featureID ? 1 : props.layout.colorOpacity,\n        zIndex: props.hoverID === featureID ? 999 : 998\n      };\n    } //   onMouse\n    ,\n    onEachFeature: function onEachFeature(feature, layer) {\n      // const variable=feature.properties[props.data.selectedVariable];\n      // const normalizer=props.data.normalizedBy ? feature.properties[props.data.normalizedBy] : 1\n      // const value = variable/normalizer;\n      // console.log(feature.geometry.type);\n      var featureID = feature.properties[props.hoverField]; // console.log(String(value))\n\n      layer.bindTooltip(String(featureID)).on('mouseover', function (e) {\n        //   console.log(featureID);\n        //   console.log(e)\n        props.handleHover(featureID);\n      });\n    },\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 85\n    },\n    __self: this\n  });\n};\n\nexport default GeoJSONLayer;","map":{"version":3,"sources":["/Users/erikwoodworth/Coding/ARC/data-arc/src/components/MapLayers/GeoJSONLayer/index.js"],"names":["React","L","GeoJSON","colormap","GeoJSONLayer","props","numberOfBins","layout","colorMap","reverse","colorMapReverse","colors","nshades","format","alpha","valueArray","data","features","filter","feature","properties","selectedVariable","map","variable","maxValue","Math","max","minValue","min","geojsonData","normalizer","normalizedBy","value","distFromMin","range","binningRatio","indexRange","color","floor","featureID","hoverField","hoverID","weight","fillColor","fillOpacity","colorOpacity","zIndex","layer","bindTooltip","String","on","e","handleHover"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport L from 'leaflet';\nimport { GeoJSON } from 'react-leaflet';\nimport colormap from 'colormap';\n\n\nconst GeoJSONLayer = props => {\n\n  // console.log(props.data)\n\n  // const pointData = props.data.geojson.map(feature => feature.geometry.type === 'Point' ? L. : null);\n\n  // console.log(props.data ? props.data : 'no data to geojson layer yet');\n\n  const numberOfBins = props.layout.numberOfBins;\n  const colorMap = props.layout.colorMap;\n  const reverse = props.layout.colorMapReverse;\n\n//  props.data.geojson ? props.data.geojson.forEach(feature => feature.geometry.type === 'Point' ? L.pointToLayer(feature.geometry.type) : console.log('Is not point')) : null;\n\n\n  const colors = reverse ? colormap({\n    colormap: colorMap,\n    nshades: numberOfBins,\n    format: 'hex',\n    alpha: 1\n  }).reverse() : colormap({\n    colormap: colorMap,\n    nshades: numberOfBins,\n    format: 'hex',\n    alpha: 1\n  });\n\n  const valueArray = props.data ? props.data.features\n    .filter(feature => feature.properties[props.selectedVariable])\n    .map(feature => {\n    \n      const variable = feature.properties[props.selectedVariable];\n    //   const normalizer=props.normalizedBy ? feature.properties[props.normalizedBy] : 1\n        // console.log(variable ? variable : null);\n        return variable}) : null;\n\n  const maxValue = valueArray !== null ? Math.max(...valueArray) : 'Value array not load yet';\n  const minValue = valueArray !== null ? Math.min(...valueArray) : 'Value array not load yet';\n\n  // console.log(valueArray ? valueArray : 'no value array');\n  \n  // console.log(props.data)\n    // console.log(maxValue);\n    // console.log(minValue);\n\n\n  const geojsonData = props.data ? props.data : null;\n  // console.log(geojsonData);\n  \n//   props.geographyFilter ? \n//   //If there's a filter type\n//   props.data.filter(feature => \n//     feature.properties[props.selectedVariable] > 0 && feature.properties[props.geographyFilter] === props.geographyFilterValue )\n//   //If there isn't a filter type\n//     : props.data;\n\n  // const pointData = dataArray.map(feature => feature.geometry.type === 'Point' ? console.log(feature.geometry.type) : null);\n  // var geojsonMarkerOptions = {\n  //   radius: 20,\n  //   fillColor: \"#ff7800\",\n  //   color: \"#000\",\n  //   weight: 1,\n  //   opacity: 1,\n  //   fillOpacity: 0.8\n  // };\n\n  // const pointData = dataArray && props.data.point ? dataArray.map(feature => L.circleMarker(feature.geometry.coordinates, geojsonMarkerOptions)) : null;\n  //   // L.geoJSON(dataArray, {\n  //   // pointToLayer: (feature, latlng) => {\n  //   //   console.log(\"This is a point\")\n  //   //   return L.circleMarker(latlng, geojsonMarkerOptions )\n  //   // }\n  //   // }) \n\n\n\n  return (\n\n      <GeoJSON\n      key={'geojson-layer'}\n      data={ geojsonData }\n    //   pointToLayer={props.data.point ? (feature, latlng) => {\n        \n    //     const variable=feature.properties[props.data.selectedVariable];\n    //     const normalizer=props.data.normalizedBy ? feature.properties[props.data.normalizedBy] : 1\n\n    //     // console.log(props.data.selectedVariable);\n    //     const value = variable/normalizer;\n    //     const distFromMin = value - minValue;\n    //     const range = maxValue - minValue;\n    //     const binningRatio = distFromMin/range;\n    //     const indexRange = numberOfBins - 1;\n    //     // const opacity = value;\n    //     const color = colors[Math.floor(binningRatio * indexRange)];\n\n    //     // const featureID = feature.properties[props.data.hoverField];\n\n    //     var geojsonMarkerOptions = {\n    //       // radius: 10,\n    //       fillColor: color,\n    //       color: \"#000\",\n    //       weight: 1,\n    //     };  \n        \n    //     // console.log(\"This is a point\")\n    //       return L.circleMarker(latlng, geojsonMarkerOptions )\n    //               .setRadius(5)\n    //     } : null \n    //   }\n\n\n      style={ feature => {\n        const variable = feature.properties ? feature.properties[props.selectedVariable] : null;\n        const normalizer = props.normalizedBy ? feature.properties[props.normalizedBy] : 1;\n\n        // console.log(props.data.selectedVariable);\n        const value = variable/normalizer;\n        const distFromMin = value - minValue;\n        const range = maxValue - minValue;\n        const binningRatio = distFromMin/range;\n        const indexRange = numberOfBins - 1;\n        // const opacity = value;\n        const color = value ? colors[Math.floor(value === 0 ? 0 : binningRatio * indexRange)] : null;\n\n        const featureID = feature.properties[props.hoverField];\n\n\n        // console.log(featureID);\n\n          return ({\n            color: props.hoverID === featureID ? 'black' : '#1a1d62',\n            weight: props.hoverID === featureID ? 3 : 0.4,\n            fillColor: color,\n            fillOpacity: !value ? 0 : props.hoverID === featureID ? 1 : props.layout.colorOpacity,\n            zIndex: props.hoverID === featureID ? 999 : 998\n          })\n        }\n      }\n\n    //   onMouse\n\n      onEachFeature={(feature, layer) => {\n          \n        // const variable=feature.properties[props.data.selectedVariable];\n        // const normalizer=props.data.normalizedBy ? feature.properties[props.data.normalizedBy] : 1\n\n        // const value = variable/normalizer;\n\n        // console.log(feature.geometry.type);\n        \n        const featureID = feature.properties[props.hoverField];\n        // console.log(String(value))\n\n        layer.bindTooltip(String(featureID))\n          .on('mouseover', e => {\n            //   console.log(featureID);\n            //   console.log(e)\n              props.handleHover(featureID)\n            });\n      }}\n    />\n  );\n};\n\nexport default GeoJSONLayer;"]},"metadata":{},"sourceType":"module"}