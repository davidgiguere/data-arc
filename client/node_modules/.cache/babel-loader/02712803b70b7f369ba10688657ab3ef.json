{"ast":null,"code":"(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"exports\", \"react\", \"prop-types\", \"./Table\", \"./Row\", \"./Cell\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(exports, require(\"react\"), require(\"prop-types\"), require(\"./Table\"), require(\"./Row\"), require(\"./Cell\"));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports, global.react, global.propTypes, global.Table, global.Row, global.Cell);\n    global.index = mod.exports;\n  }\n})(this, function (_exports, _react, _propTypes, _Table, _Row, _Cell) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  Object.defineProperty(_exports, \"Table\", {\n    enumerable: true,\n    get: function get() {\n      return _Table[\"default\"];\n    }\n  });\n  Object.defineProperty(_exports, \"Row\", {\n    enumerable: true,\n    get: function get() {\n      return _Row[\"default\"];\n    }\n  });\n  Object.defineProperty(_exports, \"Cell\", {\n    enumerable: true,\n    get: function get() {\n      return _Cell[\"default\"];\n    }\n  });\n  _exports.StickyTable = void 0;\n  _react = _interopRequireWildcard(_react);\n  _propTypes = _interopRequireDefault(_propTypes);\n  _Table = _interopRequireDefault(_Table);\n  _Row = _interopRequireDefault(_Row);\n  _Cell = _interopRequireDefault(_Cell);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n\n  function _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    } else {\n      var newObj = {};\n\n      if (obj != null) {\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n            if (desc.get || desc.set) {\n              Object.defineProperty(newObj, key, desc);\n            } else {\n              newObj[key] = obj[key];\n            }\n          }\n        }\n      }\n\n      newObj[\"default\"] = obj;\n      return newObj;\n    }\n  }\n\n  function _typeof(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function _typeof(obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function _typeof(obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  var index = 0;\n  /**\n   * StickyTable Component\n   * Responsive, dynamically sized fixed headers and columns for tables\n   * ------------------------------------------------------------------\n   * Intentionally not setting state because we don't want to require\n   * a full re-render every time the user scrolls or changes the\n   * width of a cell.\n   */\n\n  var StickyTable =\n  /*#__PURE__*/\n  function (_PureComponent) {\n    _inherits(StickyTable, _PureComponent);\n\n    function StickyTable(props) {\n      var _this;\n\n      _classCallCheck(this, StickyTable);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(StickyTable).call(this, props));\n      _this.index = index = index + 1;\n      return _this;\n    }\n    /**\n     * Get the column and header to render\n     * @returns {undefined}\n     */\n\n\n    _createClass(StickyTable, [{\n      key: \"render\",\n      value: function render() {\n        var _this$props = this.props,\n            stickyColumnCount = _this$props.stickyColumnCount,\n            stickyHeaderCount = _this$props.stickyHeaderCount;\n        stickyColumnCount = Math.min(stickyColumnCount, 1);\n        stickyHeaderCount = Math.min(stickyHeaderCount, 1);\n        return _react[\"default\"].createElement(\"div\", {\n          className: \"sticky-table sticky-table-\".concat(this.index) + (this.props.className || '')\n        }, _react[\"default\"].createElement(\"style\", null, \"\\n            .sticky-table-\".concat(this.index, \" .sticky-table-row:nth-child(-n+\").concat(stickyHeaderCount, \") .sticky-table-cell {\\n              position: -webkit-sticky;\\n              position: sticky;\\n              top: 0;\\n              z-index: 2;\\n            }\\n            .sticky-table-\").concat(this.index, \" .sticky-table-row .sticky-table-cell:nth-child(-n+\").concat(stickyColumnCount, \") {\\n              position: -webkit-sticky;\\n              position: sticky;\\n              left: 0;\\n              z-index: 2;\\n            }\\n            .sticky-table-\").concat(this.index, \" .sticky-table-row:nth-child(-n+\").concat(stickyHeaderCount, \") .sticky-table-cell:nth-child(-n+\").concat(stickyColumnCount, \") {\\n              position: -webkit-sticky;\\n              position: sticky;\\n              top: 0;\\n              left: 0;\\n              z-index: 3;\\n            }\\n          \")), _react[\"default\"].createElement(_Table[\"default\"], null, this.props.children));\n      }\n    }]);\n\n    return StickyTable;\n  }(_react.PureComponent);\n\n  _exports.StickyTable = StickyTable;\n\n  _defineProperty(StickyTable, \"propTypes\", {\n    stickyHeaderCount: _propTypes[\"default\"].number,\n    stickyColumnCount: _propTypes[\"default\"].number,\n    onScroll: _propTypes[\"default\"].func\n  });\n\n  _defineProperty(StickyTable, \"defaultProps\", {\n    stickyHeaderCount: 1,\n    stickyColumnCount: 1\n  });\n});","map":null,"metadata":{},"sourceType":"script"}